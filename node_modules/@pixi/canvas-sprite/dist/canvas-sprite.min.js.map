{"version":3,"file":"canvas-sprite.min.js","sources":["../src/CanvasSpriteRenderer.js","../src/Sprite.js"],"sourcesContent":["import { SCALE_MODES, BLEND_MODES } from '@pixi/constants';\nimport { Matrix, groupD8 } from '@pixi/math';\nimport { canvasUtils } from '@pixi/canvas-renderer';\n\nconst canvasRenderWorldTransform = new Matrix();\n\n/**\n * Types that can be passed to drawImage\n * @typedef {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap} ICanvasImageSource\n * @memberof PIXI\n */\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasSpriteRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\nexport class CanvasSpriteRenderer\n{\n    /**\n     * @param {PIXI.Renderer} renderer -The renderer sprite this batch works for.\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Renders the sprite object.\n     *\n     * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch\n     */\n    render(sprite)\n    {\n        const texture = sprite._texture;\n        const renderer = this.renderer;\n        const context = renderer.context;\n\n        const width = texture._frame.width;\n        const height = texture._frame.height;\n\n        let wt = sprite.transform.worldTransform;\n        let dx = 0;\n        let dy = 0;\n\n        const source = texture.baseTexture.getDrawableSource();\n\n        if (texture.orig.width <= 0 || texture.orig.height <= 0 || !source)\n        {\n            return;\n        }\n\n        if (!texture.valid)\n        {\n            return;\n        }\n\n        renderer.setBlendMode(sprite.blendMode, true);\n\n        renderer.context.globalAlpha = sprite.worldAlpha;\n\n        // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture\n        const smoothingEnabled = texture.baseTexture.scaleMode === SCALE_MODES.LINEAR;\n\n        if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled)\n        {\n            context[renderer.smoothProperty] = smoothingEnabled;\n        }\n\n        if (texture.trim)\n        {\n            dx = (texture.trim.width / 2) + texture.trim.x - (sprite.anchor.x * texture.orig.width);\n            dy = (texture.trim.height / 2) + texture.trim.y - (sprite.anchor.y * texture.orig.height);\n        }\n        else\n        {\n            dx = (0.5 - sprite.anchor.x) * texture.orig.width;\n            dy = (0.5 - sprite.anchor.y) * texture.orig.height;\n        }\n\n        if (texture.rotate)\n        {\n            wt.copyTo(canvasRenderWorldTransform);\n            wt = canvasRenderWorldTransform;\n            groupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);\n            // the anchor has already been applied above, so lets set it to zero\n            dx = 0;\n            dy = 0;\n        }\n\n        dx -= width / 2;\n        dy -= height / 2;\n\n        // Allow for pixel rounding\n        if (sprite.roundPixels)\n        {\n            renderer.context.setTransform(\n                wt.a,\n                wt.b,\n                wt.c,\n                wt.d,\n                (wt.tx * renderer.resolution) | 0,\n                (wt.ty * renderer.resolution) | 0\n            );\n\n            dx = dx | 0;\n            dy = dy | 0;\n        }\n        else\n        {\n            renderer.context.setTransform(\n                wt.a,\n                wt.b,\n                wt.c,\n                wt.d,\n                wt.tx * renderer.resolution,\n                wt.ty * renderer.resolution\n            );\n        }\n\n        const resolution = texture.baseTexture.resolution;\n        const outerBlend = renderer._outerBlend;\n\n        if (outerBlend)\n        {\n            context.save();\n            context.beginPath();\n            context.rect(\n                dx * renderer.resolution,\n                dy * renderer.resolution,\n                width * renderer.resolution,\n                height * renderer.resolution\n            );\n            context.clip();\n        }\n\n        if (sprite.tint !== 0xFFFFFF)\n        {\n            if (sprite._cachedTint !== sprite.tint || sprite._tintedCanvas.tintId !== sprite._texture._updateID)\n            {\n                sprite._cachedTint = sprite.tint;\n\n                // TODO clean up caching - how to clean up the caches?\n                sprite._tintedCanvas = canvasUtils.getTintedCanvas(sprite, sprite.tint);\n            }\n\n            context.drawImage(\n                sprite._tintedCanvas,\n                0,\n                0,\n                Math.floor(width * resolution),\n                Math.floor(height * resolution),\n                Math.floor(dx * renderer.resolution),\n                Math.floor(dy * renderer.resolution),\n                Math.floor(width * renderer.resolution),\n                Math.floor(height * renderer.resolution)\n            );\n        }\n        else\n        {\n            context.drawImage(\n                source,\n                texture._frame.x * resolution,\n                texture._frame.y * resolution,\n                Math.floor(width * resolution),\n                Math.floor(height * resolution),\n                Math.floor(dx * renderer.resolution),\n                Math.floor(dy * renderer.resolution),\n                Math.floor(width * renderer.resolution),\n                Math.floor(height * renderer.resolution)\n            );\n        }\n\n        if (outerBlend)\n        {\n            context.restore();\n        }\n        // just in case, leaking outer blend here will be catastrophic!\n        renderer.setBlendMode(BLEND_MODES.NORMAL);\n    }\n\n    /**\n     * destroy the sprite object.\n     *\n     */\n    destroy()\n    {\n        this.renderer = null;\n    }\n}\n","import { Sprite } from '@pixi/sprite';\n\n/**\n * Cached tinted texture.\n * @memberof PIXI.Sprite#\n * @member {HTMLCanvasElement} _tintedCanvas\n * @protected\n */\nSprite.prototype._tintedCanvas = null;\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @private\n* @method _renderCanvas\n* @memberof PIXI.Sprite#\n* @param {PIXI.CanvasRenderer} renderer - The renderer\n*/\nSprite.prototype._renderCanvas = function _renderCanvas(renderer)\n{\n    renderer.plugins.sprite.render(this);\n};\n"],"names":["const","canvasRenderWorldTransform","Matrix","CanvasSpriteRenderer","renderer","this","render","sprite","texture","_texture","context","width","_frame","height","wt","transform","worldTransform","dx","dy","source","baseTexture","getDrawableSource","orig","valid","setBlendMode","blendMode","globalAlpha","worldAlpha","smoothingEnabled","scaleMode","SCALE_MODES","LINEAR","smoothProperty","trim","x","anchor","y","rotate","copyTo","groupD8","matrixAppendRotationInv","roundPixels","setTransform","a","b","c","d","tx","resolution","ty","outerBlend","_outerBlend","save","beginPath","rect","clip","tint","_cachedTint","_tintedCanvas","tintId","_updateID","canvasUtils","getTintedCanvas","drawImage","Math","floor","restore","BLEND_MODES","NORMAL","destroy","prototype","_renderCanvas","plugins"],"mappings":"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"}