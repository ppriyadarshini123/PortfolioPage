{"version":3,"file":"canvas-particles.min.js","sources":["../src/ParticleContainer.js"],"sourcesContent":["import { ParticleContainer } from '@pixi/particles';\n\n/**\n * Renders the object using the Canvas renderer\n * @method renderCanvas\n * @memberof PIXI.ParticleContainer#\n * @private\n * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n */\nParticleContainer.prototype.renderCanvas = function renderCanvas(renderer)\n{\n    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)\n    {\n        return;\n    }\n\n    const context = renderer.context;\n    const transform = this.worldTransform;\n    let isRotated = true;\n\n    let positionX = 0;\n    let positionY = 0;\n\n    let finalWidth = 0;\n    let finalHeight = 0;\n\n    renderer.setBlendMode(this.blendMode);\n\n    context.globalAlpha = this.worldAlpha;\n\n    this.displayObjectUpdateTransform();\n\n    for (let i = 0; i < this.children.length; ++i)\n    {\n        const child = this.children[i];\n\n        if (!child.visible)\n        {\n            continue;\n        }\n\n        const frame = child._texture.frame;\n\n        context.globalAlpha = this.worldAlpha * child.alpha;\n\n        if (child.rotation % (Math.PI * 2) === 0)\n        {\n            // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call\n            if (isRotated)\n            {\n                context.setTransform(\n                    transform.a,\n                    transform.b,\n                    transform.c,\n                    transform.d,\n                    transform.tx * renderer.resolution,\n                    transform.ty * renderer.resolution\n                );\n\n                isRotated = false;\n            }\n\n            positionX = ((child.anchor.x) * (-frame.width * child.scale.x)) + child.position.x + 0.5;\n            positionY = ((child.anchor.y) * (-frame.height * child.scale.y)) + child.position.y + 0.5;\n\n            finalWidth = frame.width * child.scale.x;\n            finalHeight = frame.height * child.scale.y;\n        }\n        else\n        {\n            if (!isRotated)\n            {\n                isRotated = true;\n            }\n\n            child.displayObjectUpdateTransform();\n\n            const childTransform = child.worldTransform;\n\n            if (this.roundPixels)\n            {\n                context.setTransform(\n                    childTransform.a,\n                    childTransform.b,\n                    childTransform.c,\n                    childTransform.d,\n                    (childTransform.tx * renderer.resolution) | 0,\n                    (childTransform.ty * renderer.resolution) | 0\n                );\n            }\n            else\n            {\n                context.setTransform(\n                    childTransform.a,\n                    childTransform.b,\n                    childTransform.c,\n                    childTransform.d,\n                    childTransform.tx * renderer.resolution,\n                    childTransform.ty * renderer.resolution\n                );\n            }\n\n            positionX = ((child.anchor.x) * (-frame.width)) + 0.5;\n            positionY = ((child.anchor.y) * (-frame.height)) + 0.5;\n\n            finalWidth = frame.width;\n            finalHeight = frame.height;\n        }\n\n        const resolution = child._texture.baseTexture.resolution;\n\n        context.drawImage(\n            child._texture.baseTexture.source,\n            frame.x * resolution,\n            frame.y * resolution,\n            frame.width * resolution,\n            frame.height * resolution,\n            positionX * renderer.resolution,\n            positionY * renderer.resolution,\n            finalWidth * renderer.resolution,\n            finalHeight * renderer.resolution\n        );\n    }\n};\n"],"names":["prototype","renderCanvas","renderer","this","visible","worldAlpha","children","length","renderable","const","context","transform","worldTransform","isRotated","positionX","positionY","finalWidth","finalHeight","setBlendMode","blendMode","globalAlpha","displayObjectUpdateTransform","let","i","child","frame","_texture","alpha","rotation","Math","PI","setTransform","a","b","c","d","tx","resolution","ty","anchor","width","scale","x","position","height","y","childTransform","roundPixels","baseTexture","drawImage","source"],"mappings":";;;;;;;wEASkBA,UAAUC,aAAe,SAAsBC,GAE7D,GAAKC,KAAKC,WAAWD,KAAKE,YAAc,IAAMF,KAAKG,SAASC,QAAWJ,KAAKK,WAA5E,CAKAC,IAAMC,EAAUR,EAASQ,QACnBC,EAAYR,KAAKS,eACnBC,GAAY,EAEZC,EAAY,EACZC,EAAY,EAEZC,EAAa,EACbC,EAAc,EAElBf,EAASgB,aAAaf,KAAKgB,WAE3BT,EAAQU,YAAcjB,KAAKE,WAE3BF,KAAKkB,+BAEL,IAAKC,IAAIC,EAAI,EAAGA,EAAIpB,KAAKG,SAASC,SAAUgB,EAC5C,CACId,IAAMe,EAAQrB,KAAKG,SAASiB,GAE5B,GAAKC,EAAMpB,QAAX,CAKAK,IAAMgB,EAAQD,EAAME,SAASD,MAI7B,GAFAf,EAAQU,YAAcjB,KAAKE,WAAamB,EAAMG,MAE1CH,EAAMI,UAAsB,EAAVC,KAAKC,KAAY,EAG/BjB,IAEAH,EAAQqB,aACJpB,EAAUqB,EACVrB,EAAUsB,EACVtB,EAAUuB,EACVvB,EAAUwB,EACVxB,EAAUyB,GAAKlC,EAASmC,WACxB1B,EAAU2B,GAAKpC,EAASmC,YAG5BxB,GAAY,GAGhBC,EAAcU,EAAMe,OAAQ,IAAMd,EAAMe,MAAQhB,EAAMiB,MAAMC,GAAMlB,EAAMmB,SAASD,EAAI,GACrF3B,EAAcS,EAAMe,OAAQ,IAAMd,EAAMmB,OAASpB,EAAMiB,MAAMI,GAAMrB,EAAMmB,SAASE,EAAI,GAEtF7B,EAAaS,EAAMe,MAAQhB,EAAMiB,MAAMC,EACvCzB,EAAcQ,EAAMmB,OAASpB,EAAMiB,MAAMI,MAG7C,CACShC,IAEDA,GAAY,GAGhBW,EAAMH,+BAENZ,IAAMqC,EAAiBtB,EAAMZ,eAEzBT,KAAK4C,YAELrC,EAAQqB,aACJe,EAAed,EACfc,EAAeb,EACfa,EAAeZ,EACfY,EAAeX,EACdW,EAAeV,GAAKlC,EAASmC,WAAc,EAC3CS,EAAeR,GAAKpC,EAASmC,WAAc,GAKhD3B,EAAQqB,aACJe,EAAed,EACfc,EAAeb,EACfa,EAAeZ,EACfY,EAAeX,EACfW,EAAeV,GAAKlC,EAASmC,WAC7BS,EAAeR,GAAKpC,EAASmC,YAIrCvB,EAAcU,EAAMe,OAAQ,GAAMd,EAAMe,MAAU,GAClDzB,EAAcS,EAAMe,OAAQ,GAAMd,EAAMmB,OAAW,GAEnD5B,EAAaS,EAAMe,MACnBvB,EAAcQ,EAAMmB,OAGxBnC,IAAM4B,EAAab,EAAME,SAASsB,YAAYX,WAE9C3B,EAAQuC,UACJzB,EAAME,SAASsB,YAAYE,OAC3BzB,EAAMiB,EAAIL,EACVZ,EAAMoB,EAAIR,EACVZ,EAAMe,MAAQH,EACdZ,EAAMmB,OAASP,EACfvB,EAAYZ,EAASmC,WACrBtB,EAAYb,EAASmC,WACrBrB,EAAad,EAASmC,WACtBpB,EAAcf,EAASmC"}