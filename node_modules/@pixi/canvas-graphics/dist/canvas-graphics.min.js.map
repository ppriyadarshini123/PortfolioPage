{"version":3,"file":"canvas-graphics.min.js","sources":["../src/Graphics.js","../src/CanvasGraphicsRenderer.js"],"sourcesContent":["import { Graphics } from '@pixi/graphics';\nimport { CanvasRenderer } from '@pixi/canvas-renderer';\nimport { RenderTexture, Texture } from '@pixi/core';\nimport { Matrix } from '@pixi/math';\n\nlet canvasRenderer;\nconst tempMatrix = new Matrix();\n\n/**\n * Generates a canvas texture. Only available with **pixi.js-legacy** bundle\n * or the **@pixi/canvas-graphics** package.\n * @method generateCanvasTexture\n * @memberof PIXI.Graphics#\n * @param {number} scaleMode - The scale mode of the texture.\n * @param {number} resolution - The resolution of the texture.\n * @return {PIXI.Texture} The new texture.\n */\nGraphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode, resolution = 1)\n{\n    const bounds = this.getLocalBounds();\n\n    const canvasBuffer = RenderTexture.create(bounds.width, bounds.height, scaleMode, resolution);\n\n    if (!canvasRenderer)\n    {\n        canvasRenderer = new CanvasRenderer();\n    }\n\n    this.transform.updateLocalTransform();\n    this.transform.localTransform.copyTo(tempMatrix);\n\n    tempMatrix.invert();\n\n    tempMatrix.tx -= bounds.x;\n    tempMatrix.ty -= bounds.y;\n\n    canvasRenderer.render(this, canvasBuffer, true, tempMatrix);\n\n    const texture = Texture.from(canvasBuffer.baseTexture._canvasRenderTarget.canvas, {\n        scaleMode,\n    });\n\n    texture.baseTexture.resolution = resolution;\n    texture.baseTexture.update();\n\n    return texture;\n};\n\nGraphics.prototype.cachedGraphicsData = [];\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @method _renderCanvas\n * @memberof PIXI.Graphics#\n * @private\n * @param {PIXI.CanvasRenderer} renderer - The renderer\n */\nGraphics.prototype._renderCanvas = function _renderCanvas(renderer)\n{\n    if (this.isMask === true)\n    {\n        return;\n    }\n\n    this.finishPoly();\n    renderer.plugins.graphics.render(this);\n};\n","import { SHAPES } from '@pixi/math';\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they\n * now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasGraphicsRenderer:\n * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching graphics objects.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\nexport class CanvasGraphicsRenderer\n{\n    /**\n     * @param {PIXI.CanvasRenderer} renderer - The current PIXI renderer.\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Renders a Graphics object to a canvas.\n     *\n     * @param {PIXI.Graphics} graphics - the actual graphics object to render\n     */\n    render(graphics)\n    {\n        const renderer = this.renderer;\n        const context = renderer.context;\n        const worldAlpha = graphics.worldAlpha;\n        const transform = graphics.transform.worldTransform;\n        const resolution = renderer.resolution;\n\n        context.setTransform(\n            transform.a * resolution,\n            transform.b * resolution,\n            transform.c * resolution,\n            transform.d * resolution,\n            transform.tx * resolution,\n            transform.ty * resolution\n        );\n\n        // update tint if graphics was dirty\n        if (graphics.canvasTintDirty !== graphics.geometry.dirty\n            || graphics._prevTint !== graphics.tint)\n        {\n            this.updateGraphicsTint(graphics);\n        }\n\n        renderer.setBlendMode(graphics.blendMode);\n\n        const graphicsData = graphics.geometry.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; i++)\n        {\n            const data = graphicsData[i];\n            const shape = data.shape;\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n\n            const fillColor = data._fillTint;\n            const lineColor = data._lineTint;\n\n            context.lineWidth = lineStyle.width;\n\n            if (data.type === SHAPES.POLY)\n            {\n                context.beginPath();\n\n                let points = shape.points;\n                const holes = data.holes;\n                let outerArea;\n                let innerArea;\n                let px;\n                let py;\n\n                context.moveTo(points[0], points[1]);\n\n                for (let j = 2; j < points.length; j += 2)\n                {\n                    context.lineTo(points[j], points[j + 1]);\n                }\n\n                if (shape.closeStroke)\n                {\n                    context.closePath();\n                }\n\n                if (holes.length > 0)\n                {\n                    outerArea = 0;\n                    px = points[0];\n                    py = points[1];\n                    for (let j = 2; j + 2 < points.length; j += 2)\n                    {\n                        outerArea += ((points[j] - px) * (points[j + 3] - py))\n                            - ((points[j + 2] - px) * (points[j + 1] - py));\n                    }\n\n                    for (let k = 0; k < holes.length; k++)\n                    {\n                        points = holes[k].shape.points;\n\n                        if (!points)\n                        {\n                            continue;\n                        }\n\n                        innerArea = 0;\n                        px = points[0];\n                        py = points[1];\n                        for (let j = 2; j + 2 < points.length; j += 2)\n                        {\n                            innerArea += ((points[j] - px) * (points[j + 3] - py))\n                                - ((points[j + 2] - px) * (points[j + 1] - py));\n                        }\n\n                        if (innerArea * outerArea < 0)\n                        {\n                            context.moveTo(points[0], points[1]);\n\n                            for (let j = 2; j < points.length; j += 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n                        else\n                        {\n                            context.moveTo(points[points.length - 2], points[points.length - 1]);\n\n                            for (let j = points.length - 4; j >= 0; j -= 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n\n                        if (holes[k].shape.closeStroke)\n                        {\n                            context.closePath();\n                        }\n                    }\n                }\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n\n                    context.fillStyle = `#${(`00000${(fillColor | 0).toString(16)}`).substr(-6)}`;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = `#${(`00000${(lineColor | 0).toString(16)}`).substr(-6)}`;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.RECT)\n            {\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = `#${(`00000${(fillColor | 0).toString(16)}`).substr(-6)}`;\n                    context.fillRect(shape.x, shape.y, shape.width, shape.height);\n                }\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = `#${(`00000${(lineColor | 0).toString(16)}`).substr(-6)}`;\n                    context.strokeRect(shape.x, shape.y, shape.width, shape.height);\n                }\n            }\n            else if (data.type === SHAPES.CIRC)\n            {\n                // TODO - need to be Undefined!\n                context.beginPath();\n                context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = `#${(`00000${(fillColor | 0).toString(16)}`).substr(-6)}`;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = `#${(`00000${(lineColor | 0).toString(16)}`).substr(-6)}`;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.ELIP)\n            {\n                // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n                const w = shape.width * 2;\n                const h = shape.height * 2;\n\n                const x = shape.x - (w / 2);\n                const y = shape.y - (h / 2);\n\n                context.beginPath();\n\n                const kappa = 0.5522848;\n                const ox = (w / 2) * kappa; // control point offset horizontal\n                const oy = (h / 2) * kappa; // control point offset vertical\n                const xe = x + w; // x-end\n                const ye = y + h; // y-end\n                const xm = x + (w / 2); // x-middle\n                const ym = y + (h / 2); // y-middle\n\n                context.moveTo(x, ym);\n                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = `#${(`00000${(fillColor | 0).toString(16)}`).substr(-6)}`;\n                    context.fill();\n                }\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = `#${(`00000${(lineColor | 0).toString(16)}`).substr(-6)}`;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.RREC)\n            {\n                const rx = shape.x;\n                const ry = shape.y;\n                const width = shape.width;\n                const height = shape.height;\n                let radius = shape.radius;\n\n                const maxRadius = Math.min(width, height) / 2 | 0;\n\n                radius = radius > maxRadius ? maxRadius : radius;\n\n                context.beginPath();\n                context.moveTo(rx, ry + radius);\n                context.lineTo(rx, ry + height - radius);\n                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n                context.lineTo(rx + width - radius, ry + height);\n                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n                context.lineTo(rx + width, ry + radius);\n                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n                context.lineTo(rx + radius, ry);\n                context.quadraticCurveTo(rx, ry, rx, ry + radius);\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = `#${(`00000${(fillColor | 0).toString(16)}`).substr(-6)}`;\n                    context.fill();\n                }\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = `#${(`00000${(lineColor | 0).toString(16)}`).substr(-6)}`;\n                    context.stroke();\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates the tint of a graphics object\n     *\n     * @protected\n     * @param {PIXI.Graphics} graphics - the graphics that will have its tint updated\n     */\n    updateGraphicsTint(graphics)\n    {\n        graphics._prevTint = graphics.tint;\n        graphics.canvasTintDirty = graphics.geometry.dirty;\n\n        const tintR = ((graphics.tint >> 16) & 0xFF) / 255;\n        const tintG = ((graphics.tint >> 8) & 0xFF) / 255;\n        const tintB = (graphics.tint & 0xFF) / 255;\n        const graphicsData = graphics.geometry.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            const fillColor = data.fillStyle.color | 0;\n            const lineColor = data.lineStyle.color | 0;\n\n            // super inline, cos optimization :)\n            data._fillTint = (\n                (((fillColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)\n                + (((fillColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)\n                + (((fillColor & 0xFF) / 255) * tintB * 255)\n            );\n\n            data._lineTint = (\n                (((lineColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)\n                + (((lineColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)\n                + (((lineColor & 0xFF) / 255) * tintB * 255)\n            );\n        }\n    }\n\n    /**\n     * destroy graphics object\n     *\n     */\n    destroy()\n    {\n        this.renderer = null;\n    }\n}\n"],"names":["canvasRenderer","CanvasGraphicsRenderer","renderer","this","render","graphics","const","context","worldAlpha","transform","worldTransform","resolution","setTransform","a","b","c","d","tx","ty","canvasTintDirty","geometry","dirty","_prevTint","tint","updateGraphicsTint","setBlendMode","blendMode","graphicsData","i","length","data","shape","fillStyle","lineStyle","fillColor","_fillTint","lineColor","_lineTint","lineWidth","width","type","SHAPES","POLY","beginPath","let","points","holes","outerArea","innerArea","px","py","moveTo","j","lineTo","closeStroke","closePath","k","visible","globalAlpha","alpha","toString","substr","fill","strokeStyle","stroke","RECT","fillRect","x","y","height","strokeRect","CIRC","arc","radius","Math","PI","ELIP","w","h","ox","oy","xe","ye","xm","ym","bezierCurveTo","RREC","rx","ry","maxRadius","min","quadraticCurveTo","tintR","tintG","tintB","color","destroy","tempMatrix","Matrix","prototype","generateCanvasTexture","scaleMode","bounds","getLocalBounds","canvasBuffer","RenderTexture","create","CanvasRenderer","updateLocalTransform","localTransform","copyTo","invert","texture","Texture","from","baseTexture","_canvasRenderTarget","canvas","update","cachedGraphicsData","_renderCanvas","isMask","finishPoly","plugins"],"mappings":"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"}